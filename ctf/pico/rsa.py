## Returns gcd, x, y such that a*x + b*y = gcd
def ext_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x, y = ext_gcd(b, a % b)
    return gcd, y, x - (a//b) * y

def inv_0(a, n):
  g, x, y = ext_gcd(n, a)
  assert g == 1  # a, n are relatively prime
  return y % n

# Summary:
# pick p, q prime (transient)
# compute n = p*q (public)
# compute tot = (p-1)*(q-1) (transient)
# pick e with 1 < e < tot, gcd(e, tot) == 1 (usually 65537) (public)
# compute d = inv(e) mod tot (secret)
# public key: n, e
# private key: d
# Encrypt: c = pow(m, e) mod n
# Decrypt: m = pow(c, d) mod n

q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559

p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637

n = p*q

tot = (p-1)*(q-1)

print inv_0(65537, tot)  # d


p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
n =  23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239

q = n / p
tot = (p-1)*(q-1)

e = 65537

d = inv_0(e, tot)

ciphertext = 23016653876847472700856653975636134833816267659423093220825802730311792688015526031010185862796820464000740538663367868273628190558574669769926145909966799940743138330542504400318814444877763931323239980099404303323064601116168860363364840864265724602533013776878867287027908763538326145208488830881872675088750689066949453757107611076477999369848061893166820131477255959664458909576462597878213732662606021276850039344887619097192724271061026030900796808157479658550935169474101799591059725002019677640101543801616541273658841153594862740548434726220958512298690110880142486139412015047636595600919146971517653734739

plain = pow(ciphertext, d, n)
plain = '%x' % plain  # hex(plain)[2:-1]
#print ''.join([chr(int(plain[i:i+2], 16)) for i in range(0, len(plain), 2)])
print plain.decode('hex')

# b00tl3gRSA3
c = 28815717803054656855149685029245421696088276628360162357199401996095372693554632067446536623736903495922848990309753526430211398945530644374584341999136209406466082743000004880289765244861770429259872446067202219220301889367385381770017781009981630204450937307803734587570572772262388867322208381542260816375021056782257767694300420118900827387

n = 44403179320242858722644656929079846220023384818322415624229655831453099340520867417718500917061357667810532396311886540212014246772713056248623982256997388993770932402056111284158933145730500074823202810176601550954848916853661905323420973945303310838418874370666079981061258490133574843640907336123970531068254244129757734643498969078228162463

e = 65537

# https://sourceforge.net/projects/yafu/
# https://www.alpertron.com.ar/ECM.HTM
# sudo apt-get install gmp-ecm
# $ ecm 1e6
from subprocess import PIPE, Popen
composites = [ n ]
primes = []
n_tries = 0
while composites:
  cur = composites.pop()
  p = Popen(['ecm', '-q', '1e5'], stdin=PIPE, stdout=PIPE)
  p.stdin.write(str(cur) + '\n')
  f = p.stdout.readline()
  p.stdin.close()
  p.wait()
  print 'progress:', f
  factors = f.rstrip().split()
  if len(factors) == 1:
      n_tries += 1
      if n_tries > 5:
        n_tries = 0
        primes.append(int(factors[0]))
      else:
        composites.append(cur)
  else:
      n_tries = 0
      composites += factors
# =>
#primes = [9689951981, 9707334473, 10198012273, 10227480871, 10455318539, 11780943539, 12238455337, 14289284921, 14318378303, 15312823549, 15383419789, 15547561793, 15596253433, 16045798451, 16196850323, 16594818377, 120324768952029660859L, 136926510133308333479L, 138243718399967268427L, 139229836098975259117L, 209578970826368215937L, 229757833102772356189L, 1870977326131124537014324968953L, 2084961136552589104597762323413L]
actualprimes = [9458691337, 9492375073, 9689951981, 9707334473, 9749822141, 10198012273, 10227480871, 10455318539, 10755984131, 10900929359, 11038028501, 11303417809, 11614983641, 11780943539, 11987088437, 12238455337, 12892904539, 13083073411, 14044000819, 14289284921, 14290466947, 14318378303, 14563659499, 15312823549, 15383419789, 15388935907, 15547561793, 15596253433, 16045798451, 16077699487, 16196850323, 16255372883, 16594818377, 16848340559]
print set(primes) - set(actualprimes)
print set(actualprimes) - set(primes)


#print sorted(primes)
print reduce(lambda a, b: a*b, primes, 1) == n


tot = reduce(lambda a, b: a*b, [p - 1 for p in primes], 1)
print 'tot', tot
d = inv_0(e, tot)
print ext_gcd(tot, e), (d*e) % tot
print 'd', d
plain = pow(c, d, n)
print 'plain', ('%x' % plain)
print 'plain', ('%x' % plain).decode('hex')



###

# openssl x509 -text -in cert
