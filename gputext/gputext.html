<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta charset="utf-8">
<title>GPU Text</title>

<style>
@media(prefers-color-scheme:dark) {
  body {
    color:#E8EAED;
    background:#202124;
  }
}
</style>

<canvas id="canvas" width="700" height="150"></canvas>
<canvas id="glcanvas" width="700" height="150"></canvas>
<h1>Log</h1>
<pre id="log"></pre>
<script>
function log(a) {
  document.getElementById('log').textContent += a;
}
</script>
<script src="ttf_reader.js"></script>
<script>
function drawContour(ctx, points) {
  for (let i = 0; i < points.length; ++i) {
    const point = points[i];
    const {x, y} = point;
    if (i === 0) {
      // The first point should always be isOnCurve.
      // FIXME: I think this is wrong, see leftmost glyph in figure 13 at
      // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html
      ctx.moveTo(x, y)
      continue;
    }

    if (point.isOnCurve) {
      ctx.lineTo(x, y);
      continue;
    }

    const next = points[i < points.length - 1 ? i + 1 : 0];
    if (next.isOnCurve) {
      ctx.quadraticCurveTo(x, y, next.x, next.y);
      ++i;
    } else {
      // https://stackoverflow.com/questions/20733790/truetype-fonts-glyph-are-made-of-quadratic-bezier-why-do-more-than-one-consecu
      ctx.quadraticCurveTo(x, y, (x + next.x) / 2, (y + next.y) / 2);
    }
  }
}

function drawSimpleGlyph(ctx, glyph) {
  ctx.beginPath();
  for (let i = 0; i < glyph.contours.length; ++i)
    drawContour(ctx, glyph.contours[i]);
  ctx.fill();
}

function drawCompoundGlyph(ttf, ctx, glyph) {
  for (let glyphRef of glyph.glyphRefs) {
    const glyph = ttf.glyphForGlyphIndex(glyphRef.componentGlyphIndex);
    ctx.save();
    ctx.transform(glyphRef.m00, glyphRef.m10,
                  glyphRef.m01, glyphRef.m11,
                  glyphRef.m02, glyphRef.m12);
    drawGlyph(ttf, ctx, glyph);
    ctx.restore();
  }
}

function drawGlyph(ttf, ctx, glyph) {
  if (glyph.hasOwnProperty('glyphRefs'))
    drawCompoundGlyph(ttf, ctx, glyph);
  else
    drawSimpleGlyph(ctx, glyph);
}

function adjustCanvasForHighDPI(canvas) {
  // This intentionally doesn't handle non-fractional zoom so that the canvas
  // pixel size is always an integer multiple of the display size.
  // FIXME: Since this doesn't `ctx.scale()` (see below), fractional sizes
  // might not be a problem. Then again, if I ever add line drawing (for
  // glyph metrics or what), it will become one and I'll have to add the
  // scale factor on the context anyways.
  const scale = Math.trunc(window.devicePixelRatio);
  if (scale === 1)
    return;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  canvas.width *= scale;
  canvas.height *= scale;
  // Most pages recommend `ctx.scale(scale, scale)` here, but the drawing code
  // below normalizes everything to canvas.{width,height} (i.e. using pixels,
  // not view units). So no need for this here.
}

function compileShader(gl, shaderType, shaderSource) {
  const shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    return shader;

  log(`failed to compile shader: ${gl.getShaderInfoLog(shader)}\n`);
  gl.deleteShader(shader);
}

function linkProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS))
    return program;

  log(`failed to link program: ${gl.getProgramInfoLog(program)}\n`);
  gl.deleteProgram(program);
}

function compileProgram(gl, vertexShaderSource, fragmentShaderSource) {
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader =
      compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  return linkProgram(gl, vertexShader, fragmentShader);
}

function contourToTriangles(points) {
  let fanPoints = [];
  let curvePoints = [];
  for (let i = 0; i < points.length; ++i) {
    const point = points[i];
    const {x, y} = point;
    if (i === 0) {
      // The first point should always be isOnCurve.
      // FIXME: I think this is wrong, see leftmost glyph in figure 13 at
      // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html
      fanPoints.push(x, y)
      continue;
    }

    if (point.isOnCurve) {
      fanPoints.push(x, y)
      continue;
    }

    const next = points[i < points.length - 1 ? i + 1 : 0];
    curvePoints.push(fanPoints[fanPoints.length - 2],
                     fanPoints[fanPoints.length - 1]);
    curvePoints.push(x, y);
    if (next.isOnCurve) {
      curvePoints.push(next.x, next.y);
      fanPoints.push(next.x, next.y);
      ++i;
    } else {
      // https://stackoverflow.com/questions/20733790/truetype-fonts-glyph-are-made-of-quadratic-bezier-why-do-more-than-one-consecu
      curvePoints.push((x + next.x) / 2, (y + next.y) / 2);
      fanPoints.push((x + next.x) / 2, (y + next.y) / 2);
    }
  }
  return [fanPoints, curvePoints];
}

function drawGlphGPU(gl, positionAttributeLoc, glyph, ttf, tx, colorLoc) {
  const positionBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);

  let allFans = [];
  let allCurveTris = [];
  let fanStarts = [];
  let fanLengths = [];
  for (let i = 0; i < glyph.contours.length; ++i) {
    const [fan, tris] = contourToTriangles(glyph.contours[i]);
    fanStarts.push(allFans.length / 2);
    fanLengths.push(fan.length / 2);
    allFans.push(...fan);
    allCurveTris.push(...tris);
  }

  let allCoords = allFans.concat(allCurveTris);
  const curveTrisStart = allFans.length / 2;
  const curveTrisLength = allCurveTris.length / 2;

  // Scale glyph to viewport coords. FIXME: actual transform matrix instead.
  const s2 = Math.min(1 / (ttf.head.xMax - ttf.head.xMin),
                      1 / (ttf.head.yMax - ttf.head.yMin));
  for (let i = 0; i < allCoords.length; i += 2) {
    allCoords[i] = (allCoords[i] + tx) * s2;
    allCoords[i + 1] *= s2 * (canvas.width / canvas.height);
    allCoords[i + 1] -= 0.9;
  }
  // FIXME: This should prepare buffers just once and then use the existing
  // buffers at draw time.
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allCoords), gl.STATIC_DRAW);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  gl.enableVertexAttribArray(positionAttributeLoc);

  gl.vertexAttribPointer(
      positionAttributeLoc, /*size=*/2, gl.FLOAT, /*normalize=*/false,
      /*stride=*/0, /*offset=*/0)

  // 1. Draw glyphs to stencil buffer.
  gl.enable(gl.STENCIL_TEST);
  gl.stencilFunc(gl.ALWAYS, /*ref=*/0, /*mask=*/0xff);
  gl.stencilOp(/*fail=*/gl.KEEP, /*zfail=*/gl.INVERT, /*zpass=*/gl.INVERT);
  gl.colorMask(false, false, false, false);

  gl.bindVertexArray(vao);
  for (let i = 0; i < fanStarts.length; ++i)
    gl.drawArrays(gl.TRIANGLE_FAN,
                  /*offset=*/fanStarts[i], /*count=*/fanLengths[i]);
  gl.drawArrays(gl.TRIANGLES,
                /*offset=*/curveTrisStart, /*count=*/curveTrisLength);

  // 2. Draw shape covering glyph only where stencil test passes.
  gl.stencilFunc(gl.NOTEQUAL, /*ref=*/0, /*mask=*/0xff);
  gl.stencilOp(/*fail=*/gl.KEEP, /*zfail=*/gl.KEEP, /*zpass=*/gl.KEEP);
  gl.colorMask(true, true, true, true);

  //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  //gl.enable(gl.BLEND);

  // FIXME: draw something guaranteed to cover the whole glyph
  //        (this won't work once curves are rendered too)
  gl.uniform4f(colorLoc, 0, 0, 0, 0.1);
  for (let i = 0; i < fanStarts.length; ++i)
    gl.drawArrays(gl.TRIANGLE_FAN,
                  /*offset=*/fanStarts[i], /*count=*/fanLengths[i]);
  gl.uniform4f(colorLoc, 0.4, 0.2, 0.2, 0.1);

  gl.disable(gl.STENCIL_TEST);
  gl.drawArrays(gl.TRIANGLES,
                /*offset=*/curveTrisStart, /*count=*/curveTrisLength);
}

async function go(font_url) {
  const response = await fetch(font_url);
  if (!response.ok)
    throw new Error(`fetch failed: ${response.status}`);

  const buffer = await response.arrayBuffer();
  const ttf = new TTFReader(buffer);

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {alpha: false});

  // FIXME: Consider installing a change eventlistener for resolution changes,
  // so that the backing is updated on page zoom change, or when the window
  // is moved from a highdpi screen to a normal one and back. See
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio,
  // "Monitoring screen resolution or zoom level changes".
  adjustCanvasForHighDPI(canvas);

  ctx.fillStyle = 'rgb(255, 255, 255)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Put origin in lower-left corner.
  ctx.translate(0, canvas.height);
  ctx.scale(1, -1);

  // Make glyphs fit in canvas.
  const s = Math.min(canvas.width / (ttf.head.xMax - ttf.head.xMin),
                     canvas.height / (ttf.head.yMax - ttf.head.yMin));
  ctx.scale(s, s);
  ctx.translate(0 /*-ttf.head.xMin*/, -ttf.head.yMin);

  ctx.fillStyle = 'rgb(0, 0, 0)';

  for (let c of 'Hållお, Wörld!') {
    const glyph = ttf.glyphForChar(c);
    if (glyph !== null)
      drawGlyph(ttf, ctx, glyph);
    ctx.translate(ttf.advanceWidthForChar(c), 0);
  }

  const glcanvas = document.getElementById('glcanvas');
  adjustCanvasForHighDPI(glcanvas);

  const gl = glcanvas.getContext('webgl2', {alpha: false, stencil: true});
  if (gl === null) {
    log('failed to create webgl context\n');
    return;
  }

  const vertexShaderSource = `#version 300 es
    in vec4 position;
    void main() { gl_Position = position; }
  `;
  const fragmentShaderSource = `#version 300 es
    precision highp float;
    uniform vec4 u_color;
    out vec4 outColor;
    void main() { outColor = u_color; }
  `;
  const program = compileProgram(gl, vertexShaderSource, fragmentShaderSource);

  const positionAttributeLoc = gl.getAttribLocation(program, 'position');
  gl.useProgram(program);

  var colorLoc = gl.getUniformLocation(program, 'u_color');

  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

  let tx = -canvas.width * 2.8;
  for (let c of 'Hellodh!') {
    const glyph = ttf.glyphForChar(c);
    if (glyph !== null)
      drawGlphGPU(gl, positionAttributeLoc, glyph, ttf, tx, colorLoc);
    tx += ttf.advanceWidthForChar(c);
  }
}

window.addEventListener('DOMContentLoaded',function () {
  let url = 'https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Me5Q.ttf';
  go(url).catch(e => log(e));
});
</script>
