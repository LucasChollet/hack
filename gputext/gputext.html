<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta charset="utf-8">
<title>GPU Text</title>

<style>
@media(prefers-color-scheme:dark) {
  body {
    color:#E8EAED;
    background:#202124;
  }
}
</style>

<canvas id="glcanvas" width="700" height="150"></canvas>
<h1>Log</h1>
<pre id="log"></pre>
<script>
function log(a) {
  document.getElementById('log').textContent += a;
}
</script>
<script src="ttf_reader.js"></script>
<script>
function adjustCanvasForHighDPI(canvas) {
  // This intentionally doesn't handle non-fractional zoom so that the canvas
  // pixel size is always an integer multiple of the display size.
  // FIXME: Since this doesn't `ctx.scale()` (see below), fractional sizes
  // might not be a problem. Then again, if I ever add line drawing (for
  // glyph metrics or what), it will become one and I'll have to add the
  // scale factor on the context anyways.
  const scale = Math.trunc(window.devicePixelRatio);
  if (scale === 1)
    return;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  canvas.width *= scale;
  canvas.height *= scale;
  // Most pages recommend `ctx.scale(scale, scale)` here, but the drawing code
  // below normalizes everything to canvas.{width,height} (i.e. using pixels,
  // not view units). So no need for this here.
}

function compileShader(gl, shaderType, shaderSource) {
  const shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    return shader;

  log(`failed to compile shader: ${gl.getShaderInfoLog(shader)}\n`);
  gl.deleteShader(shader);
}

function linkProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS))
    return program;

  log(`failed to link program: ${gl.getProgramInfoLog(program)}\n`);
  gl.deleteProgram(program);
}

function compileProgram(gl, vertexShaderSource, fragmentShaderSource) {
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader =
      compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  return linkProgram(gl, vertexShader, fragmentShader);
}

function contourToTriangles(points) {
  let fanPoints = [];
  let curvePoints = [];
  for (let i = 0; i < points.length; ++i) {
    const point = points[i];
    const {x, y} = point;
    if (i === 0) {
      // The first point should always be isOnCurve.
      // FIXME: I think this is wrong, see leftmost glyph in figure 13 at
      // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html
      fanPoints.push(x, y)
      continue;
    }

    if (point.isOnCurve) {
      fanPoints.push(x, y)
      continue;
    }

    const next = points[i < points.length - 1 ? i + 1 : 0];
    curvePoints.push(fanPoints[fanPoints.length - 2],
                     fanPoints[fanPoints.length - 1], 0, 0);
    curvePoints.push(x, y, 0.5, 0);
    if (next.isOnCurve) {
      curvePoints.push(next.x, next.y, 1, 1);
      fanPoints.push(next.x, next.y);
      ++i;
    } else {
      // https://stackoverflow.com/questions/20733790/truetype-fonts-glyph-are-made-of-quadratic-bezier-why-do-more-than-one-consecu
      curvePoints.push((x + next.x) / 2, (y + next.y) / 2, 1, 1);
      fanPoints.push((x + next.x) / 2, (y + next.y) / 2);
    }
  }
  return [fanPoints, curvePoints];
}

function drawGlphGPU(gl, glcanvas,
                     fanProgram,
                     fanMatrixLoc, fanPositionAttributeLoc, fanColorLoc,
                     triProgram,
                     triMatrixLoc, triPositionAttributeLoc, triColorLoc,
                     glyph, matrix) {
  let allFans = [];
  let allCurveTris = [];
  let fanStarts = [];
  let fanLengths = [];
  for (let i = 0; i < glyph.contours.length; ++i) {
    const [fan, tris] = contourToTriangles(glyph.contours[i]);
    fanStarts.push(allFans.length / 2);
    fanLengths.push(fan.length / 2);
    allFans.push(...fan);
    allCurveTris.push(...tris);
  }

  const curveTrisStart = allFans.length / 2;
  const curveTrisLength = allCurveTris.length / 4;
  let allCoords = allFans.concat(allCurveTris);

  // FIXME: This should prepare buffers just once and then use the existing
  // buffers at draw time.
  const positionBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allCoords), gl.STATIC_DRAW);

  const fanVao = gl.createVertexArray();
  gl.bindVertexArray(fanVao);
  gl.enableVertexAttribArray(fanPositionAttributeLoc);
  gl.vertexAttribPointer(
      fanPositionAttributeLoc, /*size=*/2, gl.FLOAT, /*normalize=*/false,
      /*stride=*/0, /*offset=*/0)

  const triVao = gl.createVertexArray();
  gl.bindVertexArray(triVao);
  gl.enableVertexAttribArray(triPositionAttributeLoc);
  gl.vertexAttribPointer(
      triPositionAttributeLoc, /*size=*/4, gl.FLOAT, /*normalize=*/false,
      /*stride=*/0,
      /*offset=*/curveTrisStart * /*floats per vertex*/ 2 * /*sizeof float*/ 4);

  // 1. Draw glyphs to stencil buffer.
  gl.enable(gl.STENCIL_TEST);
  gl.stencilFunc(gl.ALWAYS, /*ref=*/0, /*mask=*/0xff);
  gl.stencilOp(/*fail=*/gl.KEEP, /*zfail=*/gl.INVERT, /*zpass=*/gl.INVERT);
  gl.colorMask(false, false, false, false);

  gl.useProgram(fanProgram);
  gl.uniformMatrix4fv(fanMatrixLoc, /*transpose=*/true, matrix);
  gl.bindVertexArray(fanVao);
  for (let i = 0; i < fanStarts.length; ++i)
    gl.drawArrays(gl.TRIANGLE_FAN,
                  /*offset=*/fanStarts[i], /*count=*/fanLengths[i]);
  gl.useProgram(triProgram);
  gl.uniformMatrix4fv(triMatrixLoc, /*transpose=*/true, matrix);
  gl.bindVertexArray(triVao);
  gl.drawArrays(gl.TRIANGLES,
                /*offset=*/0, /*count=*/curveTrisLength);

  // 2. Draw shape covering glyph only where stencil test passes.
  gl.stencilFunc(gl.NOTEQUAL, /*ref=*/0, /*mask=*/0xff);
  gl.stencilOp(/*fail=*/gl.KEEP, /*zfail=*/gl.KEEP, /*zpass=*/gl.KEEP);
  gl.colorMask(true, true, true, true);

  //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  //gl.enable(gl.BLEND);

  // FIXME: draw something guaranteed to cover the whole glyph
  //        (this won't work once curves are rendered too)
  gl.useProgram(fanProgram);
  gl.uniform4f(fanColorLoc, 0, 0, 0, 0.1);
  gl.bindVertexArray(fanVao);
  for (let i = 0; i < fanStarts.length; ++i)
    gl.drawArrays(gl.TRIANGLE_FAN,
                  /*offset=*/fanStarts[i], /*count=*/fanLengths[i]);


  //gl.disable(gl.STENCIL_TEST);
  gl.useProgram(triProgram);
  gl.uniform4f(triColorLoc, 0.4, 0.2, 0.2, 0.1);
  gl.bindVertexArray(triVao);
  gl.drawArrays(gl.TRIANGLES,
                /*offset=*/0, /*count=*/curveTrisLength);
}

async function go(font_url) {
  const response = await fetch(font_url);
  if (!response.ok)
    throw new Error(`fetch failed: ${response.status}`);

  const buffer = await response.arrayBuffer();
  const ttf = new TTFReader(buffer);

  const glcanvas = document.getElementById('glcanvas');
  adjustCanvasForHighDPI(glcanvas);

  const gl = glcanvas.getContext('webgl2', {alpha: false, stencil: true});
  if (gl === null) {
    log('failed to create webgl context\n');
    return;
  }

  const fanVertexShaderSource = `#version 300 es
    uniform mat4 u_matrix;
    in vec2 position;
    void main() { gl_Position = u_matrix * vec4(position, 0.0, 1.0); }
  `;
  const fanFragmentShaderSource = `#version 300 es
    precision highp float;
    uniform vec4 u_color;
    out vec4 outColor;
    void main() { outColor = u_color; }
  `;
  const fanProgram =
      compileProgram(gl, fanVertexShaderSource, fanFragmentShaderSource);
  const fanMatrixLoc = gl.getUniformLocation(fanProgram, 'u_matrix');
  const fanPositionAttributeLoc = gl.getAttribLocation(fanProgram, 'position');
  const fanColorLoc = gl.getUniformLocation(fanProgram, 'u_color');

  const triVertexShaderSource = `#version 300 es
    uniform mat4 u_matrix;
    in vec4 position;
    out vec2 uv;
    void main() {
      uv = position.zw;
      gl_Position = u_matrix * vec4(position.xy, 0.0, 1.0);
    }
  `;
  const triFragmentShaderSource = `#version 300 es
    precision highp float;
    uniform vec4 u_color;
    in vec2 uv;
    out vec4 outColor;
    void main() {
      if (uv.x*uv.x - uv.y > 0.0)
        discard;
      outColor = u_color;
    }
  `;
  const triProgram =
      compileProgram(gl, triVertexShaderSource, triFragmentShaderSource);
  const triMatrixLoc = gl.getUniformLocation(triProgram, 'u_matrix');
  const triPositionAttributeLoc = gl.getAttribLocation(triProgram, 'position');
  const triColorLoc = gl.getUniformLocation(triProgram, 'u_color');

  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

  // Scale glyph to viewport coords.
  const sx = Math.min(1 / (ttf.head.xMax - ttf.head.xMin),
                      1 / (ttf.head.yMax - ttf.head.yMin));
  const sy = sx * (glcanvas.width / glcanvas.height);
  const matrix = [
    sx, 0 , 0, 0,
    0 , sy, 0, -0.9,
    0 , 0 , 1, 0,
    0 , 0 , 0, 1,
  ];

  let tx = -glcanvas.width * 2.8;
  for (let c of 'Hellodh!') {
    const glyph = ttf.glyphForChar(c);
    if (glyph !== null) {
      matrix[3] = tx * sx;
      drawGlphGPU(gl, glcanvas,
                  fanProgram,
                  fanMatrixLoc, fanPositionAttributeLoc, fanColorLoc,
                  triProgram,
                  triMatrixLoc, triPositionAttributeLoc, triColorLoc,
                  glyph, matrix);
    }
    tx += ttf.advanceWidthForChar(c);
  }
}

window.addEventListener('DOMContentLoaded',function () {
  let url = 'https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Me5Q.ttf';
  go(url).catch(e => log(e));
});
</script>
